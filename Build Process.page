- The build process (may it be triggered by a commit, or just run as a nightly task) should happen in a clean environment, simulating a fresh Haskell Platform environment, thus only having Cabal (and cabal-install) and GHC together with their dependencies.
- We're currently investigating how the isolation will be performed: hsenv, virthualenv or just cabal-dev.
- It should be able to fetch packages either from Hackage or from repositories (darcs for sure, and probably git too -- darcs-bridge?).
- It should test building the package by only fetching (when possible) the dependencies from hackage, just like it would happen if someone was trying to install your project -- e.g, we would fetch hslogger from hackage if trying to build happstack-server.
- Maybe we should also try to build the project with the HEAD versions of the dependencies (if we specify a repo for them)? That would thus let the developer of the project anticipate some breakages with upcoming versions of the project's dependencies.

Basically, we may have to do some distinction between a pure "Testing" mode, that would only try building against the hackage versions of the dependencies, and a kind of "Advanced testing" mode that would fetch the development versions of the dependencies from their repositories. The former would be perfect for on-commit builds and for nightly builds, while the latter would only make sense for nightly/weekly builds, for example.

- [HackageDB format spec](http://hackage.haskell.org/trac/hackage/wiki/HackageDB#Structure)

Also, some irc log:
    <stepkut> alpounet: most likely
    <alpounet> so this is basically about passing the right --with-ghc and --with-ghc-pkg (or smth like that) to handle ghc, and having a                local thing for compiled packages
    <alpounet> + (i don't know how we can handle this) the libraries provided by HP
    <alpounet> in that same local thing
    <stepkut> alpounet: the tools like hsenv, cabal-dev, etc, are intended to be used interactively by developers
    <stepkut> alpounet: they do not provide libraries, and tend to affect things globally.. which means you could not run multiple builds     in parallel on the same machine
    <alpounet> yeah
    <stepkut> it would be nice to have something that was completely independent of your global haskell enviroment
    <stepkut> like.. it would be nice if it could take the haskell platform .tar.gz files as input, and go from there, installing everything in a separate completely isolated enviroment from your global environment
    <stepkut> given the fact that hsenv, capri, cabal-dev, virthual env are around ~1000 lines each.. I don't think it is a huge task.     Especially when we can copy what they do for the most part?
    <alpounet> yeah
    <alpounet> but downloading the HP files will take forever!
    <stepkut> alpounet: well, you would only download them once
    <alpounet> the binary files aren't exactly lightweight :P
    <stepkut> alpounet: and probably only unpack them once
    <alpounet> and then we can use our shiny copyDir function :P
    <stepkut> alpounet: not sure we even need to do that.. we can, hopefully, just install the platform once in some private directory, and then have 'cabal install' install its extra things into some secondary directory that we can easily wipe afterwards
    <alpounet> alright
    <stepkut> alpounet: but, if not, then we can just use the copyDir function to copy that clean enviroment
    <alpounet> ok so we would have some different HP versions sitting somewhere in a scoutess dir
    <stepkut> yeah
    <alpounet> and each build would use this and a per-build folder to cabal-install stuffs into a compiled package db local to that folder
    <alpounet> smth like that
    <stepkut> yeah
    <alpounet> aaaalright, sounds like a plan.
    <stepkut> it's only a plan if we write it down ;)